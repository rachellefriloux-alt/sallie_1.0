/*
Salle Persona Module: CodeOptimizationSystem
Implements advanced code optimization capabilities to improve performance, 
readability, and maintainability of code generated by Sallie.
Follows Salle architecture, modularity, and privacy rules.
*/

interface OptimizationProfile {
  id: string;
  name: string;
  description: string;
  focusAreas: Array<'performance' | 'memory' | 'readability' | 'maintainability'>;
  targetRuntime?: string;
  settings: {
    aggressiveness: number; // 0-10
    preserveComments: boolean;
    preserveFunctionSignatures: boolean;
    inlineSmallFunctions: boolean;
    extractCommonPatterns: boolean;
    optimizeLoops: boolean;
    optimizeDataStructures: boolean;
    minimizeVariableScope: boolean;
  };
}

interface OptimizationResult {
  fileId: string;
  originalSize: number;
  optimizedSize: number;
  improvementPercent: number;
  optimizedCode: string;
  changesLog: OptimizationChange[];
  metrics: {
    executionTimeImprovement?: number; // percentage
    memoryUsageImprovement?: number;   // percentage
    complexityReduction?: number;      // percentage
    readabilityImprovement?: number;   // -10 to +10 scale
  };
}

interface OptimizationChange {
  type: 'refactor' | 'rewrite' | 'inline' | 'extract' | 'algorithm' | 'dataStructure';
  description: string;
  lineStart: number;
  lineEnd: number;
  impact: 'high' | 'medium' | 'low';
}

export class CodeOptimizationSystem {
  private profiles: Map<string, OptimizationProfile> = new Map();
  private optimizationResults: Map<string, OptimizationResult[]> = new Map();
  
  constructor() {
    // Initialize with default optimization profiles
    this.initializeDefaultProfiles();
  }
  
  /**
   * Initialize default optimization profiles
   */
  private initializeDefaultProfiles(): void {
    const defaultProfiles: OptimizationProfile[] = [
      {
        id: 'performance-first',
        name: 'Performance First',
        description: 'Optimize primarily for execution speed, sacrificing some readability if needed',
        focusAreas: ['performance'],
        settings: {
          aggressiveness: 8,
          preserveComments: false,
          preserveFunctionSignatures: true,
          inlineSmallFunctions: true,
          extractCommonPatterns: true,
          optimizeLoops: true,
          optimizeDataStructures: true,
          minimizeVariableScope: true
        }
      },
      {
        id: 'balanced',
        name: 'Balanced Optimization',
        description: 'Balance between performance and maintainability',
        focusAreas: ['performance', 'readability', 'maintainability'],
        settings: {
          aggressiveness: 5,
          preserveComments: true,
          preserveFunctionSignatures: true,
          inlineSmallFunctions: false,
          extractCommonPatterns: true,
          optimizeLoops: true,
          optimizeDataStructures: true,
          minimizeVariableScope: true
        }
      },
      {
        id: 'readability-first',
        name: 'Readability First',
        description: 'Optimize for code clarity and maintainability',
        focusAreas: ['readability', 'maintainability'],
        settings: {
          aggressiveness: 3,
          preserveComments: true,
          preserveFunctionSignatures: true,
          inlineSmallFunctions: false,
          extractCommonPatterns: true,
          optimizeLoops: false,
          optimizeDataStructures: false,
          minimizeVariableScope: false
        }
      },
      {
        id: 'memory-efficient',
        name: 'Memory Efficient',
        description: 'Optimize for minimal memory usage',
        focusAreas: ['memory'],
        settings: {
          aggressiveness: 7,
          preserveComments: false,
          preserveFunctionSignatures: true,
          inlineSmallFunctions: false,
          extractCommonPatterns: true,
          optimizeLoops: true,
          optimizeDataStructures: true,
          minimizeVariableScope: true
        }
      }
    ];
    
    for (const profile of defaultProfiles) {
      this.profiles.set(profile.id, profile);
    }
  }
  
  /**
   * Create a custom optimization profile
   */
  createOptimizationProfile(
    name: string,
    description: string,
    focusAreas: Array<'performance' | 'memory' | 'readability' | 'maintainability'>,
    settings: Partial<OptimizationProfile['settings']>,
    targetRuntime?: string
  ): OptimizationProfile {
    // Generate ID
    const id = `profile_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
    
    // Apply default settings for any missing ones
    const defaultSettings = this.profiles.get('balanced')!.settings;
    
    const profile: OptimizationProfile = {
      id,
      name,
      description,
      focusAreas,
      targetRuntime,
      settings: {
        ...defaultSettings,
        ...settings
      }
    };
    
    this.profiles.set(id, profile);
    return profile;
  }
  
  /**
   * Get all available optimization profiles
   */
  getOptimizationProfiles(): OptimizationProfile[] {
    return Array.from(this.profiles.values());
  }
  
  /**
   * Get a specific profile by ID
   */
  getProfile(profileId: string): OptimizationProfile | undefined {
    return this.profiles.get(profileId);
  }
  
  /**
   * Optimize code using a specified profile
   */
  optimizeCode(
    code: string,
    language: string,
    profileId: string = 'balanced',
    fileId: string = `file_${Date.now()}`
  ): OptimizationResult {
    const profile = this.profiles.get(profileId) || this.profiles.get('balanced')!;
    const originalSize = code.length;
    
    // Track optimization changes
    const changes: OptimizationChange[] = [];
    
    // Apply optimizations based on language and profile settings
    let optimizedCode = code;
    
    // Apply different optimization strategies based on language
    switch (language.toLowerCase()) {
      case 'javascript':
      case 'typescript':
        optimizedCode = this.optimizeJavaScript(optimizedCode, profile, changes);
        break;
        
      case 'python':
        optimizedCode = this.optimizePython(optimizedCode, profile, changes);
        break;
        
      default:
        // Generic optimizations for other languages
        optimizedCode = this.applyGenericOptimizations(optimizedCode, profile, changes);
    }
    
    // Calculate metrics
    const optimizedSize = optimizedCode.length;
    const improvementPercent = Math.round((1 - optimizedSize / originalSize) * 100 * 10) / 10;
    
    // Estimate other improvements based on changes
    const executionTimeImprovement = this.estimateExecutionTimeImprovement(changes);
    const memoryUsageImprovement = this.estimateMemoryImprovement(changes);
    const complexityReduction = this.estimateComplexityReduction(changes);
    const readabilityImprovement = this.estimateReadabilityImprovement(changes, profile);
    
    // Create result
    const result: OptimizationResult = {
      fileId,
      originalSize,
      optimizedSize,
      improvementPercent,
      optimizedCode,
      changesLog: changes,
      metrics: {
        executionTimeImprovement,
        memoryUsageImprovement,
        complexityReduction,
        readabilityImprovement
      }
    };
    
    // Store the result
    if (!this.optimizationResults.has(fileId)) {
      this.optimizationResults.set(fileId, []);
    }
    this.optimizationResults.get(fileId)!.push(result);
    
    return result;
  }
  
  /**
   * Apply JavaScript/TypeScript optimizations
   */
  private optimizeJavaScript(
    code: string,
    profile: OptimizationProfile,
    changes: OptimizationChange[]
  ): string {
    let optimizedCode = code;
    const { settings } = profile;
    
    // Extract code lines for processing
    const lines = optimizedCode.split('\n');
    
    // 1. Optimize loops if enabled
    if (settings.optimizeLoops) {
      optimizedCode = this.optimizeJavaScriptLoops(optimizedCode, changes);
    }
    
    // 2. Optimize data structures if enabled
    if (settings.optimizeDataStructures) {
      optimizedCode = this.optimizeJavaScriptDataStructures(optimizedCode, changes);
    }
    
    // 3. Inline small functions if enabled
    if (settings.inlineSmallFunctions) {
      optimizedCode = this.inlineSmallFunctions(optimizedCode, 'javascript', changes);
    }
    
    // 4. Extract common patterns if enabled
    if (settings.extractCommonPatterns) {
      optimizedCode = this.extractCommonPatterns(optimizedCode, changes);
    }
    
    // 5. Minimize variable scope if enabled
    if (settings.minimizeVariableScope) {
      optimizedCode = this.minimizeJavaScriptVariableScope(optimizedCode, changes);
    }
    
    // For demonstration purposes, we'll return a simple optimization
    // (in a real implementation, the above methods would perform more sophisticated transformations)
    if (!settings.preserveComments) {
      // Remove comments (simplified example)
      const withoutComments = optimizedCode.replace(/\/\/.*$/gm, '').replace(/\/\*[\s\S]*?\*\//gm, '');
      
      if (withoutComments !== optimizedCode) {
        changes.push({
          type: 'refactor',
          description: 'Removed comments to reduce code size',
          lineStart: 1,
          lineEnd: optimizedCode.split('\n').length,
          impact: 'low'
        });
        optimizedCode = withoutComments;
      }
    }
    
    return optimizedCode;
  }
  
  /**
   * Optimize JavaScript/TypeScript loops
   */
  private optimizeJavaScriptLoops(code: string, changes: OptimizationChange[]): string {
    let optimizedCode = code;
    
    // Find for...in loops that could be optimized to for...of or forEach
    const forInRegex = /for\s*\(\s*(?:let|var|const)\s+(\w+)\s+in\s+(\w+)\s*\)\s*\{/g;
    let match;
    
    while ((match = forInRegex.exec(code)) !== null) {
      const fullMatch = match[0];
      const iterVar = match[1];
      const collection = match[2];
      
      // Look for array usage pattern
      const arrayPattern = new RegExp(`${collection}\\[${iterVar}\\]`, 'g');
      
      if (code.match(arrayPattern)) {
        // This is likely using for...in on an array, which is not optimal
        const newLoop = `for (const ${iterVar} of ${collection}) {`;
        
        const lineStart = code.substring(0, match.index).split('\n').length;
        const lineEnd = lineStart + 1;
        
        changes.push({
          type: 'refactor',
          description: `Converted for...in loop to for...of loop for better performance with array "${collection}"`,
          lineStart,
          lineEnd,
          impact: 'medium'
        });
        
        optimizedCode = optimizedCode.replace(fullMatch, newLoop);
      }
    }
    
    // Optimize array iterations (simplified example)
    // Replace traditional for loops with forEach where appropriate
    const forLoopRegex = /for\s*\(\s*(?:let|var|const)\s+(\w+)\s*=\s*0\s*;\s*\1\s*<\s*(\w+)\.length\s*;\s*\1\+\+\s*\)\s*\{/g;
    
    while ((match = forLoopRegex.exec(code)) !== null) {
      const fullMatch = match[0];
      const iterVar = match[1];
      const array = match[2];
      
      // This is a classic for loop over array indices
      const newLoop = `${array}.forEach((item, ${iterVar}) => {`;
      
      const lineStart = code.substring(0, match.index).split('\n').length;
      const lineEnd = lineStart + 1;
      
      changes.push({
        type: 'refactor',
        description: `Converted classic for loop to forEach for cleaner code with array "${array}"`,
        lineStart,
        lineEnd,
        impact: 'low'
      });
      
      optimizedCode = optimizedCode.replace(fullMatch, newLoop);
      
      // Note: This is a simplified example and would require additional processing
      // to properly handle loop body, closures, and loop endings
    }
    
    return optimizedCode;
  }
  
  /**
   * Optimize JavaScript/TypeScript data structures
   */
  private optimizeJavaScriptDataStructures(code: string, changes: OptimizationChange[]): string {
    let optimizedCode = code;
    
    // Replace array.indexOf(x) !== -1 with array.includes(x)
    const indexOfRegex = /(\w+)\.indexOf\(([^)]+)\)\s*!==?\s*-1/g;
    let match;
    
    while ((match = indexOfRegex.exec(code)) !== null) {
      const fullMatch = match[0];
      const array = match[1];
      const searchTerm = match[2];
      
      const newCheck = `${array}.includes(${searchTerm})`;
      
      const lineStart = code.substring(0, match.index).split('\n').length;
      const lineEnd = lineStart;
      
      changes.push({
        type: 'refactor',
        description: `Replaced indexOf check with includes() for more readable code`,
        lineStart,
        lineEnd,
        impact: 'low'
      });
      
      optimizedCode = optimizedCode.replace(fullMatch, newCheck);
    }
    
    // Replace object property access patterns with destructuring
    const repeatedAccessRegex = /const\s+(\w+)\s*=\s*(\w+)\.(\w+);\s*const\s+(\w+)\s*=\s*\2\.(\w+);/g;
    
    while ((match = repeatedAccessRegex.exec(code)) !== null) {
      const fullMatch = match[0];
      const var1 = match[1];
      const object = match[2];
      const prop1 = match[3];
      const var2 = match[4];
      const prop2 = match[5];
      
      // Only replace if the variables match properties
      if (var1 === prop1 && var2 === prop2) {
        const newCode = `const { ${prop1}, ${prop2} } = ${object};`;
        
        const lineStart = code.substring(0, match.index).split('\n').length;
        const lineEnd = lineStart + 1;
        
        changes.push({
          type: 'refactor',
          description: `Used object destructuring for cleaner property access on "${object}"`,
          lineStart,
          lineEnd,
          impact: 'low'
        });
        
        optimizedCode = optimizedCode.replace(fullMatch, newCode);
      }
    }
    
    return optimizedCode;
  }
  
  /**
   * Minimize JavaScript variable scope
   */
  private minimizeJavaScriptVariableScope(code: string, changes: OptimizationChange[]): string {
    let optimizedCode = code;
    
    // Replace var with let/const where possible
    const varRegex = /var\s+(\w+)\s*=\s*([^;]+);/g;
    let match;
    
    while ((match = varRegex.exec(code)) !== null) {
      const fullMatch = match[0];
      const varName = match[1];
      const varValue = match[2];
      
      // Check if the value is reassigned later
      // This is a simplified check - in reality, scope analysis would be needed
      const reassignmentRegex = new RegExp(`${varName}\\s*=`, 'g');
      const reassignmentMatches = code.match(reassignmentRegex) || [];
      
      // If there's only one match (the initial assignment), use const, otherwise use let
      const newKeyword = reassignmentMatches.length <= 1 ? 'const' : 'let';
      const newDeclaration = `${newKeyword} ${varName} = ${varValue};`;
      
      const lineStart = code.substring(0, match.index).split('\n').length;
      const lineEnd = lineStart;
      
      changes.push({
        type: 'refactor',
        description: `Replaced "var" with "${newKeyword}" for variable "${varName}" to improve variable scoping`,
        lineStart,
        lineEnd,
        impact: 'low'
      });
      
      optimizedCode = optimizedCode.replace(fullMatch, newDeclaration);
    }
    
    return optimizedCode;
  }
  
  /**
   * Apply Python optimizations
   */
  private optimizePython(
    code: string,
    profile: OptimizationProfile,
    changes: OptimizationChange[]
  ): string {
    let optimizedCode = code;
    const { settings } = profile;
    
    // Apply Python-specific optimizations
    if (settings.optimizeLoops) {
      optimizedCode = this.optimizePythonLoops(optimizedCode, changes);
    }
    
    if (settings.optimizeDataStructures) {
      optimizedCode = this.optimizePythonDataStructures(optimizedCode, changes);
    }
    
    if (!settings.preserveComments) {
      // Remove comments (simplified)
      const withoutComments = optimizedCode.replace(/#.*$/gm, '').replace(/"""[\s\S]*?"""/gm, '');
      
      if (withoutComments !== optimizedCode) {
        changes.push({
          type: 'refactor',
          description: 'Removed comments to reduce code size',
          lineStart: 1,
          lineEnd: optimizedCode.split('\n').length,
          impact: 'low'
        });
        optimizedCode = withoutComments;
      }
    }
    
    return optimizedCode;
  }
  
  /**
   * Optimize Python loops
   */
  private optimizePythonLoops(code: string, changes: OptimizationChange[]): string {
    let optimizedCode = code;
    
    // Convert range-based indexing to direct iteration
    const rangeLoopRegex = /for\s+(\w+)\s+in\s+range\(len\((\w+)\)\):/g;
    let match;
    
    while ((match = rangeLoopRegex.exec(code)) !== null) {
      const fullMatch = match[0];
      const iterVar = match[1];
      const collection = match[2];
      
      // Check if this loop uses the index to access the list
      const indexingPattern = new RegExp(`${collection}\\[${iterVar}\\]`, 'g');
      
      if (code.match(indexingPattern)) {
        // This is likely using range(len()) for indexing
        const newLoop = `for ${iterVar}_item in ${collection}:`;
        
        const lineStart = code.substring(0, match.index).split('\n').length;
        const lineEnd = lineStart + 1;
        
        changes.push({
          type: 'refactor',
          description: `Converted range-based loop to direct iteration for better performance with "${collection}"`,
          lineStart,
          lineEnd,
          impact: 'medium'
        });
        
        // This simple replacement would need additional logic to handle
        // the references inside the loop body in a real implementation
        optimizedCode = optimizedCode.replace(fullMatch, newLoop);
      } else {
        // If index is needed, convert to enumeration
        const newLoop = `for ${iterVar}, item in enumerate(${collection}):`;
        
        const lineStart = code.substring(0, match.index).split('\n').length;
        const lineEnd = lineStart + 1;
        
        changes.push({
          type: 'refactor',
          description: `Converted range-based loop to enumerate for better performance with "${collection}"`,
          lineStart,
          lineEnd,
          impact: 'medium'
        });
        
        optimizedCode = optimizedCode.replace(fullMatch, newLoop);
      }
    }
    
    return optimizedCode;
  }
  
  /**
   * Optimize Python data structures
   */
  private optimizePythonDataStructures(code: string, changes: OptimizationChange[]): string {
    let optimizedCode = code;
    
    // Replace multiple list.append() calls with list comprehensions or extends
    const appendRegex = /(\w+)\.append\(([^)]+)\)[^\S\n]*\n[^\S\n]*\1\.append\(([^)]+)\)/g;
    
    let match;
    while ((match = appendRegex.exec(code)) !== null) {
      const fullMatch = match[0];
      const listVar = match[1];
      const item1 = match[2];
      const item2 = match[3];
      
      const newCode = `${listVar}.extend([${item1}, ${item2}])`;
      
      const lineStart = code.substring(0, match.index).split('\n').length;
      const lineEnd = lineStart + 1;
      
      changes.push({
        type: 'refactor',
        description: `Replaced multiple append() calls with a single extend() for "${listVar}"`,
        lineStart,
        lineEnd,
        impact: 'low'
      });
      
      optimizedCode = optimizedCode.replace(fullMatch, newCode);
    }
    
    // Replace dict creation + updates with dict comprehension or initial values
    const dictUpdateRegex = /(\w+)\s*=\s*\{\}\s*\n[^\S\n]*\1\[([^]]+)\]\s*=\s*([^;\n]+)\s*\n[^\S\n]*\1\[([^]]+)\]\s*=\s*([^;\n]+)/g;
    
    while ((match = dictUpdateRegex.exec(code)) !== null) {
      const fullMatch = match[0];
      const dictVar = match[1];
      const key1 = match[2];
      const value1 = match[3];
      const key2 = match[4];
      const value2 = match[5];
      
      const newCode = `${dictVar} = {${key1}: ${value1}, ${key2}: ${value2}}`;
      
      const lineStart = code.substring(0, match.index).split('\n').length;
      const lineEnd = lineStart + 2;
      
      changes.push({
        type: 'refactor',
        description: `Replaced sequential dict updates with direct initialization for "${dictVar}"`,
        lineStart,
        lineEnd,
        impact: 'low'
      });
      
      optimizedCode = optimizedCode.replace(fullMatch, newCode);
    }
    
    return optimizedCode;
  }
  
  /**
   * Inline small functions when appropriate
   */
  private inlineSmallFunctions(
    code: string,
    language: string,
    changes: OptimizationChange[]
  ): string {
    // This is a placeholder for a more complex implementation
    // In a real system, this would analyze functions, determine which are small enough
    // to inline, and replace function calls with the function body
    
    // For demonstration, we'll just log that this would happen
    changes.push({
      type: 'inline',
      description: 'Function inlining analysis would identify small functions for inlining',
      lineStart: 1,
      lineEnd: 1,
      impact: 'medium'
    });
    
    return code;
  }
  
  /**
   * Extract common code patterns into shared functions
   */
  private extractCommonPatterns(code: string, changes: OptimizationChange[]): string {
    // This is a placeholder for a more complex implementation
    // In a real system, this would identify repeated code blocks and extract them
    
    // For demonstration, we'll just log that this would happen
    changes.push({
      type: 'extract',
      description: 'Pattern extraction would identify repeated code patterns for refactoring',
      lineStart: 1,
      lineEnd: 1,
      impact: 'medium'
    });
    
    return code;
  }
  
  /**
   * Apply generic optimizations that work for most languages
   */
  private applyGenericOptimizations(
    code: string,
    profile: OptimizationProfile,
    changes: OptimizationChange[]
  ): string {
    let optimizedCode = code;
    const { settings } = profile;
    
    // Remove redundant whitespace if aggressive optimization
    if (settings.aggressiveness > 6) {
      const withoutExtraWhitespace = optimizedCode.replace(/[ \t]+/g, ' ').replace(/\n+/g, '\n');
      
      if (withoutExtraWhitespace !== optimizedCode) {
        changes.push({
          type: 'refactor',
          description: 'Removed redundant whitespace',
          lineStart: 1,
          lineEnd: optimizedCode.split('\n').length,
          impact: 'low'
        });
        optimizedCode = withoutExtraWhitespace;
      }
    }
    
    return optimizedCode;
  }
  
  /**
   * Estimate execution time improvement based on changes
   */
  private estimateExecutionTimeImprovement(changes: OptimizationChange[]): number {
    // Simple heuristic to estimate execution time improvement
    let improvement = 0;
    
    for (const change of changes) {
      switch (change.impact) {
        case 'high':
          improvement += 5;
          break;
        case 'medium':
          improvement += 2;
          break;
        case 'low':
          improvement += 0.5;
          break;
      }
      
      // Additional points for algorithm and loop optimizations
      if (change.type === 'algorithm' || change.description.includes('loop')) {
        improvement += 3;
      }
    }
    
    // Cap the improvement at reasonable values
    return Math.min(Math.max(improvement, 0), 50);
  }
  
  /**
   * Estimate memory usage improvement based on changes
   */
  private estimateMemoryImprovement(changes: OptimizationChange[]): number {
    // Simple heuristic to estimate memory usage improvement
    let improvement = 0;
    
    for (const change of changes) {
      if (change.description.includes('memory') || 
          change.description.includes('data structure') || 
          change.type === 'dataStructure') {
        switch (change.impact) {
          case 'high':
            improvement += 7;
            break;
          case 'medium':
            improvement += 3;
            break;
          case 'low':
            improvement += 1;
            break;
        }
      }
    }
    
    // Cap the improvement at reasonable values
    return Math.min(Math.max(improvement, 0), 40);
  }
  
  /**
   * Estimate complexity reduction based on changes
   */
  private estimateComplexityReduction(changes: OptimizationChange[]): number {
    // Simple heuristic to estimate complexity reduction
    let reduction = 0;
    
    for (const change of changes) {
      if (change.type === 'refactor' || change.type === 'extract') {
        switch (change.impact) {
          case 'high':
            reduction += 8;
            break;
          case 'medium':
            reduction += 4;
            break;
          case 'low':
            reduction += 1;
            break;
        }
      }
    }
    
    // Cap the reduction at reasonable values
    return Math.min(Math.max(reduction, 0), 30);
  }
  
  /**
   * Estimate readability improvement based on changes and profile
   */
  private estimateReadabilityImprovement(changes: OptimizationChange[], profile: OptimizationProfile): number {
    // Readability can be positive or negative depending on the focus
    let improvement = 0;
    
    // If profile focuses on readability, changes are more likely to improve readability
    const readabilityFocused = profile.focusAreas.includes('readability');
    
    for (const change of changes) {
      if (change.description.includes('comment') && !profile.settings.preserveComments) {
        // Removing comments reduces readability
        improvement -= 2;
      }
      
      if (change.description.includes('destructuring') || 
          change.description.includes('cleaner') || 
          change.description.includes('readable')) {
        // These changes tend to improve readability
        improvement += 1;
      }
      
      // Inlining can reduce readability for larger functions
      if (change.type === 'inline') {
        improvement -= 1;
      }
      
      // Extracting patterns usually improves readability
      if (change.type === 'extract') {
        improvement += 2;
      }
    }
    
    // If profile is readability focused, boost the improvement
    if (readabilityFocused) {
      improvement = improvement * 1.5;
    }
    
    // Cap the improvement within the -10 to +10 scale
    return Math.min(Math.max(improvement, -10), 10);
  }
  
  /**
   * Get optimization history for a file
   */
  getOptimizationHistory(fileId: string): OptimizationResult[] {
    return this.optimizationResults.get(fileId) || [];
  }
  
  /**
   * Get latest optimization for a file
   */
  getLatestOptimization(fileId: string): OptimizationResult | undefined {
    const history = this.optimizationResults.get(fileId) || [];
    return history.length > 0 ? history[history.length - 1] : undefined;
  }
}
